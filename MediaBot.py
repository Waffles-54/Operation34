#######################################
# OP34: Special Operations            #
# Program Written by Alice Griffith   #
# Follow a site legal requirments     #
#######################################

from enum import Enum

import os
import subprocess
import sys

database = "internal/query.db"
download_archives = "internal/downloaded.db"
global_blacklist = "internal/blacklist.db"

class Engine(Enum):
    BOORU = 1
    PIXIV = 2
    OTHER = 3

class Rating(Enum):
    SFE = 1
    SEN = 2
    EXP = 3

class Mode(Enum):
    TAG = 1
    USR = 2

class Scraper:
    query_list = []
    @staticmethod
    def loadDatabases(module_list):
        # Load blacklist
        # Load Queries
        for mod in module_list:
            # Build the query
            query = ""
            blacklist = ""
            for element in global_blacklist:
                blacklist += element
            if mod.engine == "BRU":
                query += "https://gelbooru.com/index.php?page=post&s=list&tags="
                query += mod.query
            elif mod.engine == Engine.PIXIV:
                if mod.mode == Mode.TAG:
                    query += "https://www.pixiv.net/en/tags/"
                elif mod.mode == Mode.USR:
                    query += "https://www.pixiv.net/en/users/"
                query += mod.query + "/"
            elif mod.engine == Engine.OTHER:
                query += mod.engine
            
            query += mod.query
           # TODO (Waffles), Implement LOB
            query += "+id:>" + str(mod.lid)
            if mod.rating == "SFE":
                print()
            if mod.rating == "SEN":
                print()
            if mod.rating == "EXP":
                if mod.engine == "BRU":
                    query += "+rating:explicit"
            Scraper.query_list.append(query)

    @staticmethod
    def execute_queries(query_list):
            for query in query_list:
                # Execute Query & log output
                resCapture = subprocess.run(["gallery-dl", "--download-archive", download_archives, query], capture_output=True, text=True)
                if resCapture.stdout == "":
                    print("No output was generated by the query.")
                else:
                    with open(download_archives, 'a') as arc:
                        arc.write(resCapture.stdout)
                    # Gets the token for BRU storage
                    last_token = resCapture.stdout.splitlines()[0].split('id:>')[1].split('_')[1] if resCapture.stdout else None
                    if last_token != None:
                        mod.lid = last_token
                    else:
                        print("No token generated by query")

# Module class: represents a module to track web scraping info
class Module:
    module_list = []
    def __init__(self, engine, query, lid, lob, rating, mode):
        self.engine = engine
        self.query = query
        self.lid = lid # last id, used in automating fresh downloads
        self.lob = lob
        self.rating = rating
        self.mode = mode
        Module.module_list.append(self)
    
    @classmethod
    def load_modules(self):
        try:
            with open(database, 'r') as file:
                contents = file.read()
            queries = contents.split('@')
            for query in queries:
                if query == '':
                    break
                fragments = query.split('|')
                Module(*fragments)
        except:
            print("No database file exists, generating...")
            with open(database, 'w') as file:
                contents = file.read()

    @classmethod
    def save_modules(self):
        with open(database, 'w') as file:
            for mod in self.module_list:
                db_enc = ""
                if mod.engine == Engine.BOORU:
                    db_enc += "BRU|"
                    db_enc += mod.query + "|"
                    db_enc += str(mod.lid) + "|"
                    db_enc += mod.lob + "|"
                    if mod.rating == Rating.SFE:
                        db_enc += "SFE" + "@"
                    elif mod.rating == Rating.SEN:
                        db_enc += "SEN" + "@"
                    elif mod.rating == Rating.EXP:
                        db_enc += "EXP" + "|@"
                elif mod.engine == Engine.PIXIV:
                    db_enc += "PXV|" + str(mod.query) + "||||" + mod.mode.name2 + "@"
                    print()
                elif mod.engine == Engine.OTHER:
                    db_enc += mod.engine
                file.write(db_enc)

    @classmethod
    def add_entry(self):
        # Empty declarations
        response, engine, query, lob, rating, lid, mode = [None] * 7
        while (True):
            print("\nEnter engine # to use:")
            print("0. Exit Entry mode")
            print("1. Booru")
            print("2. Pixiv")
            print("3. Manual mode (direct query entry)")
            response = int(input())
            if response == 0:
                print("Exiting input mode...")
                return False
            elif response == 1: # Booru
                engine = Engine.BOORU
                break
            elif response == 2: # Pixiv input mode
                engine = Engine.PIXIV
                break
            elif response == 3: # Manual Mode
                engine = Engine.OTHER
                break
            sys.stdout.flush()
        sys.stdout.flush()
        
        if engine == Engine.BOORU:
            print("\nInput search query (Do not input blacklist identifiers here):")
            sys.stdout.flush()
            query = input()
            print("\nInput Local blacklists seperated by a space (Press enter for None):")
            lob = input()
            sys.stdout.flush()

            while (True):
                print("\nInput Rating # Classification:")
                print("1. Safe")
                print("2. Sensitive")
                print("3. Explicit")
                response = int(input())
                if response == 1: # Safe
                    rating = Rating.SFE
                    break
                elif response == 2: # Sensitive
                    rating = Rating.SEN
                    break
                elif response == 3: # Explicit
                    rating = Rating.EXP
                    break
                sys.stdout.flush()
            sys.stdout.flush()
            print("\nEnter the BOORU's Last ID (LID) to download from, or 0 to skip [DATABASE TRANSSFER MODE]")
            # TODO (Waffles), this will break if the user hits newline
            response = int(input())
            if response.is_integer():
                lid = response
            else:
                lid = 0
            mode = Mode.TAG
        elif engine == Engine.PIXIV:
            print("\nInput qwery mode:")
            print("1. User ID")
            print("2. Tag Search")
            response = int(input())
            if response == 1: # User input mode
                mode = Mode.USR
                print("\nInput Users ID:")
                query = int(input())
            elif response == 2: # Tag Search mode
                mode = Mode.TAG
                print("\nInput Tags:")
                query = input()

        print("\nGenerating query...")
        Module(engine, query, lid, lob, rating, mode)
        # Module(query, 0)
        # print("\n")
        return True

# Program entry point
def main():
    # Setup Step
    if not os.path.exists("internal"):
        os.makedirs("internal")
    Module.load_modules()

    # Promting Stage
    while(True):
        # Scraper.generate_queries(Module.m1odule_list) # TMP
        print("Enter Command:")
        print("-e: execute bot")
        print("-a: add to database")
        print("-b: add to global blacklist (BOORU's only)")
        print("-q: to quit")
        query = input()
        if query == "-e":
            Scraper.loadDatabases(Module.module_list)
            Scraper.execute_queries(Scraper.query_list)
        elif query == "-a":
            while(True):
                if Module.add_entry() == False:
                    break
        elif query == "-b":
            print("Enter globaly blacklisted tags to be added to the database (seperate with spaces):")
            response = input()
            tokens = response.split(' ')
            # TODO add duplication checks
            with open(global_blacklist, 'a') as file:
                for token in tokens:
                    file.write(token + "|")
        elif query == "-q":
            print("shutting down...")
            Module.save_modules()
            exit()
    
if __name__ == "__main__":  main()

####################################################################################################
# Developers TODO:
# Isolate class functionality for initialization, duplication, and writing into there own class (db managment)
# Add a significant deal more error checking to this code
# Implement propper blacklisting techniques
####################################################################################################