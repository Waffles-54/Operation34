#######################################
# OP34: Special Operations            #
# Program Written by Alice Griffith   #
# Follow local laws and regulations   #
#######################################


####################################################################################################
# Setup Phase: Import Libraries and setup global standards                                         # 
####################################################################################################
import os
import subprocess
import sys
QUERIES = "internal/query.db"                # Database for managing internal query managment
BLACKLIST = "internal/blacklist.db"          # Database for universal blacklist applications (Booru's only)
DOWNLOAD_ARCHIVES = "internal/downloaded.db" # Database achrive of downloaded files to avoid redownloading
GLOBAL_BLACKLIST = []                        # Internal structure for managing the globally applied blacklist (Booru's only)
GLOBAL_MODULES = []                          # Internal structure for maintaining modules to maintain information about quieries
GLOBAL_QUERIES = []                          # Internal structure for applying queiries generated by metadata in the global modules

####################################################################################################
# Scraper class: related to mechanisms of database managment, query building, and query execution  #
####################################################################################################
class Scraper:
    # Database loader functionality, reads GLOBAL_BLACKLIST & GLOBAL_MODULES into the program and proccesses them
    @staticmethod
    def loadDatabases():
        # Load entries into modules
        global GLOBAL_BLACKLIST
        try:
            # Load the QUERIES database into the program and proccess them, notify user if no query database exist
            with open(QUERIES, 'r') as file:
                contents = file.read()
            queries = contents.split('@')
            for query in queries:
                if query == '':
                    break
                fragments = query.split('|')
                # TODO (Waffles) Implement valid fragment testing here
                Module(*fragments) # Generate modules from the tokenized database entries
        except:
            print("No database file exists, please run -a to add queries to the query database")

        # Load and initialize the global blacklist, notify user if no entries exist
        try:
            with open(BLACKLIST, 'r') as file:
                contents = file.read().split("|")
            for element in contents:
                if element != '':
                    GLOBAL_BLACKLIST.append(element)
        except:
            print("No blacklist database file exists, please run -b to add tags to the global blacklist database")

    # Saves entries back into there respective databases
    @staticmethod
    def save_entries():
        # Proccess all active queries from the loaded databases and any new queries the user has added. Overwrites old queries with updated metadata (LOB, LID, etc.)
        with open(QUERIES, 'w') as file:
            for mod in GLOBAL_MODULES:
                try:
                    db_enc = ""
                    if mod.engine == "BRU":
                        db_enc += "BRU|"
                        db_enc += mod.query + "|"
                        db_enc += str(mod.lid) + "|"
                        for entry in mod.lob.split(" "):
                            if entry != '':
                                db_enc += entry + " "
                        db_enc += "|"
                        if mod.rating == "SFE":
                            db_enc += "SFE|"
                        elif mod.rating == "SEN":
                            db_enc += "SEN|"
                        elif mod.rating == "EXP":
                            db_enc += "EXP|"
                    elif mod.engine == "PXV":
                        db_enc += "PXV|" + str(mod.query) + "||||"
                    elif mod.engine == "OTH":
                        db_enc += mod.engine
                    db_enc += mod.mode + "@"
                    file.write(db_enc)
                except:
                    # Notify users of any failures #TODO make this into a log system
                    print("Failed to save module to database!")

    # Generate queries from active modules (loaded + user inputs)
    @staticmethod
    def generate_queries():
            global GLOBAL_QUERIES
            for module in GLOBAL_MODULES:
                # Build the queries from the modules metadata
                #TODO: Finish this, its lacking in rating classifiers
                query = ""
                if module.engine == "BRU":
                    query += "https://gelbooru.com/index.php?page=post&s=list&tags="
                    query += module.query
                    query += "+id:>" + str(module.lid)
                    if module.rating == "SFE":
                        print()
                    if module.rating == "SEN":
                        print()
                    if module.rating == "EXP":
                        if module.engine == "BRU":
                            query += "+rating:explicit"
                    for entry in GLOBAL_BLACKLIST + module.lob.split(" "):
                        if entry != '':
                            query += "+-" + entry
                elif module.engine == "PXV":
                    if module.mode == "TAG":
                        query += "https://www.pixiv.net/en/tags/"
                    elif module.mode == "USR":
                        query += "https://www.pixiv.net/en/users/"
                    query += module.query + "/"
                elif module.engine == "OTH":
                    query += module.engine
                GLOBAL_QUERIES.append(query)

    # Execute queries after they have been generated, update module metadata
    @staticmethod
    def execute_queries():
        for query in GLOBAL_QUERIES:
            # Execute Query & log output
            resCapture = subprocess.run(["gallery-dl", "--download-archive", DOWNLOAD_ARCHIVES, query], capture_output=True, text=True)
            if resCapture.stdout == "":
                print("No output was generated for" + query)
            else:
                with open(DOWNLOAD_ARCHIVES, 'a') as file:
                    print(len(resCapture.stdout.splitlines()) + " hits on the query: " + query)
                    # Send output to download archives
                    file.write(resCapture.stdout)
                #TODO fix this, needs to be set back up after the database upgrade
                # Gets the token for BRU storage
                # last_token = resCapture.stdout.splitlines()[0].split('id:>')[1].split('_')[1] if resCapture.stdout else None
                # if last_token != None:
                #     # mod.lid = last_token
                #     print()
                # else:
                #     print("No token generated by query")

# Module class: represents a module to track a queries metadata
class Module:
    global GLOBAL_MODULES
    # Module initalizer, sets up metadata for a query from either the database or user input @ runtime
    def __init__(self, engine, query, lid, lob, rating, mode):
        self.engine = engine # Engine used to execute the query
        self.query = query   # the query to be executed (TAG)
        self.lid = lid       # last id of image downloaded, used in automating fresh downloads (Booru's)
        self.lob = lob       # Local blacklisted tags
        self.rating = rating # Query image safety rating classification
        self.mode = mode     # What type of query is being executed (Tag, User, etc.)
        GLOBAL_MODULES.append(self)
    
    # Create a module to add to the database
    @classmethod
    def add_entry(self):
        # Empty declarations for databases structure
        response, engine, query, lob, rating, lid, mode = [None] * 7
        while (True): # While the user wants to add more entries
            # Determine what engine to use #TODO make this more dynamic
            print("\nEnter engine # to use:")
            print("1. Booru")
            print("2. Pixiv")
            print("3. Deviantart [NOT IMPLEMENTED YET]")
            print("4. Manual mode (direct query entry)")
            print("0. Exit Entry mode")
            response = int(input())
            if response == 0:
                print("Exiting input mode...")
                return False
            elif response == 1: # Booru
                engine = "BRU"
                break
            elif response == 2: # Pixiv input mode
                engine = "PXV"
                break
            elif response == 3: # Manual Mode
                engine = "OTH"
                break
            sys.stdout.flush()
        sys.stdout.flush()

        # Execute further steps based on the engine selected
        if engine == "BRU":
            print("\nInput search query (Do not input blacklist identifiers here):")
            sys.stdout.flush()
            query = input()
            sys.stdout.flush()
            while (True):
                # Determine image rating classification
                print("\nInput Rating # Classification:")
                print("1. Safe")
                print("2. Sensitive")
                print("3. Explicit")
                response = int(input())
                if response == 1: # Safe
                    rating = "SFE"
                    break
                elif response == 2: # Sensitive
                    rating = "SEN"
                    break
                elif response == 3: # Explicit
                    rating = "EXP"
                    break
                else:
                    print("Invalid entry! please enter a numeric value\n")
                sys.stdout.flush()
            print("\nInput Local blacklists seperated by a space (Press enter for None):")
            lob = input()
            sys.stdout.flush()
            print("\nEnter the BOORU's Last ID (LID) to download from, or Enter to skip [QUERIES TRANSSFER MODE]")
            try:
                response = int(input())
                lid = response
            except:
                if response == '':
                    lid = 0
            else:
                lid = 0
            mode = "TAG"
            print("\nGenerating query...")
            Module(engine, query, lid, lob, rating, mode)
        
        elif engine == "PXV":
            print("\nInput qwery mode:")
            print("1. User ID")
            print("2. Tag Search")
            while(True):
                response = input()
                if response == '1': # User input mode
                    mode = "USR"
                    print("\nInput Users ID's (seperate by spaces):")
                    query = input().split(' ')
                    break
                elif response == '2': # Tag Search mode
                    mode = "TAG-a"
                    print("\nInput Tags:")
                    query = input()
                    break

            print("\nGenerating query...")
            for entry in query:
                if entry != '':
                    Module(engine, entry, lid, lob, rating, mode)
        return True

# Program entry point
def main():
    # Setup Step
    if not os.path.exists("internal"):
        os.makedirs("internal")
    Scraper.loadDatabases()

    # Promting Stage
    while(True):
        # Select engine mode
        print("Enter Command:")
        print("-e: execute bot")
        print("-a: add to database")
        print("-b: add to global blacklist (BOORU's only)")
        print("-q: to quit")
        query = input()
        if query == "-e":
            Scraper.generate_queries()
            Scraper.execute_queries()
        elif query == "-a":
            while(True):
                if Module.add_entry() == False:
                    break
        elif query == "-b":
            print("Enter globaly blacklisted tags to be added to the database (seperate with spaces):")
            response = input()
            tokens = response.split(' ')
            # TODO add duplication checks
            with open(BLACKLIST, 'a') as file:
                for token in tokens:
                    file.write(token + "|")
        elif query == "-q":
            print("Saving databases...")
            Scraper.save_entries()
            print("shutting down...")
            exit()
    
if __name__ == "__main__":  main()

####################################################################################################
# Developers TODO:
# Setup an installer script
# Setup duplication analysis
# Removal system
# viewing system
# Initial first run configuration function
# Make this program cross compatible
# Make script opperatable from UNIX scheduler
# Make dabase saving more stable & Reliable
# Make engines more configurable (gelbooru, safebooru, danbooru, etc)
# Add an engine for deviantart
# Implement video scraping (Tall order, low priority)
# Implement file link batch proccessing (internal/load) or something
####################################################################################################